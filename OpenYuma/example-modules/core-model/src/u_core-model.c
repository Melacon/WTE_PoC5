
/* 
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.5-5

    User SIL module
    module core-model
    revision 2017-03-20
    namespace urn:onf:params:xml:ns:yang:core-model
    organization ONF (Open Networking Foundation) Open Transport Working Group - Wireless Transport Project

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "status.h"
#include "u_core-model.h"
#include "y_core-model.h"

#include <time.h>

#include <pthread.h>

#include <stdlib.h>

#include "utils.h"

#define XPATH_MAX_LENGTH 2048

static int32 attribute_value_changed_counter = 0;
static int32 problem_counter = 0;

/* put your static variables here */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_layer_protocol_name_edit
* 
* Edit database object callback
* Path: /network-element/fd/layer-protocol-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_layer_protocol_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_layer_protocol_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_layer_protocol_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_lower_level_fd_edit
* 
* Edit database object callback
* Path: /network-element/fd/lower-level-fd
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_lower_level_fd_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_lower_level_fd_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_lower_level_fd_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_fc_edit
* 
* Edit database object callback
* Path: /network-element/fd/fc
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_fc_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_fc_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_fc_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_ltp_edit
* 
* Edit database object callback
* Path: /network-element/fd/ltp
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_ltp_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_ltp_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_ltp_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_lower_level_link_edit
* 
* Edit database object callback
* Path: /network-element/fd/lower-level-link
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_lower_level_link_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_lower_level_link_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_lower_level_link_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_local_id_value_name_edit
* 
* Edit database object callback
* Path: /network-element/fd/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid,
    const xmlChar *k_network_element_fd_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_local_id_value_edit
* 
* Edit database object callback
* Path: /network-element/fd/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid,
    const xmlChar *k_network_element_fd_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_local_id_edit
* 
* Edit database object callback
* Path: /network-element/fd/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid,
    const xmlChar *k_network_element_fd_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_uuid_edit
* 
* Edit database object callback
* Path: /network-element/fd/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_name_value_name_edit
* 
* Edit database object callback
* Path: /network-element/fd/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid,
    const xmlChar *k_network_element_fd_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_name_value_edit
* 
* Edit database object callback
* Path: /network-element/fd/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid,
    const xmlChar *k_network_element_fd_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_name_edit
* 
* Edit database object callback
* Path: /network-element/fd/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid,
    const xmlChar *k_network_element_fd_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_label_value_name_edit
* 
* Edit database object callback
* Path: /network-element/fd/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid,
    const xmlChar *k_network_element_fd_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_label_value_edit
* 
* Edit database object callback
* Path: /network-element/fd/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid,
    const xmlChar *k_network_element_fd_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_label_edit
* 
* Edit database object callback
* Path: /network-element/fd/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid,
    const xmlChar *k_network_element_fd_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_label_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_extension_value_name_edit
* 
* Edit database object callback
* Path: /network-element/fd/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid,
    const xmlChar *k_network_element_fd_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_extension_value_edit
* 
* Edit database object callback
* Path: /network-element/fd/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid,
    const xmlChar *k_network_element_fd_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_extension_edit
* 
* Edit database object callback
* Path: /network-element/fd/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid,
    const xmlChar *k_network_element_fd_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_extension_edit */

/********************************************************************
* FUNCTION u_core_model_network_element_fd_operational_state_get
* 
* Get database object callback
* Path: /network-element/fd/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_network_element_fd_uuid)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/network-element/fd[uuid=\"%s\"]/operational-state",
        k_network_element_fd_uuid);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_network_element_fd_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_administrative_control_edit
* 
* Edit database object callback
* Path: /network-element/fd/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_network_element_fd_administrative_state_get
* 
* Get database object callback
* Path: /network-element/fd/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_network_element_fd_uuid)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/network-element/fd[uuid=\"%s\"]/administrative-state",
        k_network_element_fd_uuid);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_network_element_fd_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_lifecycle_state_edit
* 
* Edit database object callback
* Path: /network-element/fd/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_fd_edit
* 
* Edit database object callback
* Path: /network-element/fd
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_fd_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_fd_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_fd_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_fd_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_server_ltp_edit
* 
* Edit database object callback
* Path: /network-element/ltp/server-ltp
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_server_ltp_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_server_ltp_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_server_ltp_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_client_ltp_edit
* 
* Edit database object callback
* Path: /network-element/ltp/client-ltp
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_client_ltp_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_client_ltp_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_client_ltp_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_layer_protocol_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/layer-protocol-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_layer_protocol_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_layer_protocol_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_layer_protocol_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_configured_client_capacity_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/configured-client-capacity
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_configured_client_capacity_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_configured_client_capacity_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_configured_client_capacity_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_lp_direction_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/lp-direction
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_lp_direction_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_lp_direction_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_lp_direction_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_termination_state_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/termination-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_termination_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_termination_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_termination_state_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_switch_rule_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/switch-rule
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_switch_rule_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_switch_rule_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_switch_rule_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_fc_switch_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/fc-switch
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_fc_switch_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_fc_switch_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_fc_switch_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_reversion_mode_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/control-parameters/reversion-mode
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_reversion_mode_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_reversion_mode_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_reversion_mode_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_wait_to_revert_time_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/control-parameters/wait-to-revert-time
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_wait_to_revert_time_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_wait_to_revert_time_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_wait_to_revert_time_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_prot_type_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/control-parameters/prot-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_prot_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_prot_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_prot_type_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_hold_off_time_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/control-parameters/hold-off-time
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_hold_off_time_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_hold_off_time_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_hold_off_time_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_network_scheme_specification_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/control-parameters/network-scheme-specification
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_network_scheme_specification_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_network_scheme_specification_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_network_scheme_specification_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/control-parameters
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_control_parameters_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_profile_proxy_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/profile-proxy
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_profile_proxy_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_profile_proxy_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_profile_proxy_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_uuid_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_name_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_local_pac_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_name_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_local_pac_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_local_pac_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_label_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_local_pac_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_label_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_local_pac_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_label_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_local_pac_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_label_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_extension_edit */

/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_operational_state_get
* 
* Get database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/network-element/ltp[uuid=\"%s\"]/lp[uuid=\"%s\"]/config-and-switch-controller[switch-rule=\"%s\"]/local-pac/operational-state",
        k_network_element_ltp_uuid,
        k_network_element_ltp_lp_uuid,
        k_network_element_ltp_lp_config_and_switch_controller_switch_rule);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_administrative_control_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_administrative_state_get
* 
* Get database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/network-element/ltp[uuid=\"%s\"]/lp[uuid=\"%s\"]/config-and-switch-controller[switch-rule=\"%s\"]/local-pac/administrative-state",
        k_network_element_ltp_uuid,
        k_network_element_ltp_lp_uuid,
        k_network_element_ltp_lp_config_and_switch_controller_switch_rule);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_lifecycle_state_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/local-pac
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_local_pac_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_uuid_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_name_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_global_pac_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_name_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_global_pac_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_global_pac_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_label_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_global_pac_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_label_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_global_pac_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_label_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_global_pac_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_label_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_extension_edit */

/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_operational_state_get
* 
* Get database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/network-element/ltp[uuid=\"%s\"]/lp[uuid=\"%s\"]/config-and-switch-controller[switch-rule=\"%s\"]/global-pac/operational-state",
        k_network_element_ltp_uuid,
        k_network_element_ltp_lp_uuid,
        k_network_element_ltp_lp_config_and_switch_controller_switch_rule);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_administrative_control_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_administrative_state_get
* 
* Get database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/network-element/ltp[uuid=\"%s\"]/lp[uuid=\"%s\"]/config-and-switch-controller[switch-rule=\"%s\"]/global-pac/administrative-state",
        k_network_element_ltp_uuid,
        k_network_element_ltp_lp_uuid,
        k_network_element_ltp_lp_config_and_switch_controller_switch_rule);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_lifecycle_state_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/global-pac
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_global_pac_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_is_frozen_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/is-frozen
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_is_frozen_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_is_frozen_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_is_frozen_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_is_coordinated_switching_both_ends_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/is-coordinated-switching-both-ends
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_is_coordinated_switching_both_ends_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_is_coordinated_switching_both_ends_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_is_coordinated_switching_both_ends_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_subordinate_controller_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller/subordinate-controller
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_subordinate_controller_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_subordinate_controller_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_subordinate_controller_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_config_and_switch_controller_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/config-and-switch-controller
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_config_and_switch_controller_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_config_and_switch_controller_switch_rule)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_config_and_switch_controller_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_config_and_switch_controller_edit */


#ifdef u_core_model_F_protection_exclude_ltp
/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_is_protection_lock_out_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/is-protection-lock-out
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_is_protection_lock_out_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_is_protection_lock_out_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_is_protection_lock_out_edit */
#endif /* u_core_model_F_protection_exclude_ltp */

/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_fc_blocks_signal_to_lp_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/fc-blocks-signal-to-lp
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_fc_blocks_signal_to_lp_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_fc_blocks_signal_to_lp_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_fc_blocks_signal_to_lp_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_local_id_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_local_id_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_local_id_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_uuid_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_name_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_name_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_label_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_label_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_label_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_label_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_extension_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_extension_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_extension_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid,
    const xmlChar *k_network_element_ltp_lp_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_extension_edit */

/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_operational_state_get
* 
* Get database object callback
* Path: /network-element/ltp/lp/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/network-element/ltp[uuid=\"%s\"]/lp[uuid=\"%s\"]/operational-state",
        k_network_element_ltp_uuid,
        k_network_element_ltp_lp_uuid);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_network_element_ltp_lp_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_administrative_control_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_administrative_state_get
* 
* Get database object callback
* Path: /network-element/ltp/lp/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/network-element/ltp[uuid=\"%s\"]/lp[uuid=\"%s\"]/administrative-state",
        k_network_element_ltp_uuid,
        k_network_element_ltp_lp_uuid);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_network_element_ltp_lp_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_lifecycle_state_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lp_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lp
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lp_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_lp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lp_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lp_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_connected_ltp_edit
* 
* Edit database object callback
* Path: /network-element/ltp/connected-ltp
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_connected_ltp_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_connected_ltp_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_connected_ltp_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_peer_ltp_edit
* 
* Edit database object callback
* Path: /network-element/ltp/peer-ltp
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_peer_ltp_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_peer_ltp_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_peer_ltp_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_physical_port_reference_edit
* 
* Edit database object callback
* Path: /network-element/ltp/physical-port-reference
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_physical_port_reference_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_physical_port_reference_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_physical_port_reference_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_ltp_in_other_view_edit
* 
* Edit database object callback
* Path: /network-element/ltp/ltp-in-other-view
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_ltp_in_other_view_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_ltp_in_other_view_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_ltp_in_other_view_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_ltp_direction_edit
* 
* Edit database object callback
* Path: /network-element/ltp/ltp-direction
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_ltp_direction_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_ltp_direction_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_ltp_direction_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_local_id_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_local_id_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_local_id_edit
* 
* Edit database object callback
* Path: /network-element/ltp/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_uuid_edit
* 
* Edit database object callback
* Path: /network-element/ltp/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_name_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_name_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_label_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_label_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_label_edit
* 
* Edit database object callback
* Path: /network-element/ltp/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_label_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_extension_value_name_edit
* 
* Edit database object callback
* Path: /network-element/ltp/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_extension_value_edit
* 
* Edit database object callback
* Path: /network-element/ltp/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_extension_edit
* 
* Edit database object callback
* Path: /network-element/ltp/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid,
    const xmlChar *k_network_element_ltp_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_extension_edit */

/********************************************************************
* FUNCTION u_core_model_network_element_ltp_operational_state_get
* 
* Get database object callback
* Path: /network-element/ltp/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_network_element_ltp_uuid)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/network-element/ltp[uuid=\"%s\"]/operational-state",
        k_network_element_ltp_uuid);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_network_element_ltp_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_administrative_control_edit
* 
* Edit database object callback
* Path: /network-element/ltp/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_network_element_ltp_administrative_state_get
* 
* Get database object callback
* Path: /network-element/ltp/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_network_element_ltp_uuid)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/network-element/ltp[uuid=\"%s\"]/administrative-state",
        k_network_element_ltp_uuid);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_network_element_ltp_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_lifecycle_state_edit
* 
* Edit database object callback
* Path: /network-element/ltp/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_ltp_edit
* 
* Edit database object callback
* Path: /network-element/ltp
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_ltp_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_ltp_uuid)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_ltp_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_ltp_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_local_id_value_name_edit
* 
* Edit database object callback
* Path: /network-element/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_local_id_value_edit
* 
* Edit database object callback
* Path: /network-element/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_local_id_edit
* 
* Edit database object callback
* Path: /network-element/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_local_id_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_uuid_edit
* 
* Edit database object callback
* Path: /network-element/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_name_value_name_edit
* 
* Edit database object callback
* Path: /network-element/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_name_value_edit
* 
* Edit database object callback
* Path: /network-element/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_name_edit
* 
* Edit database object callback
* Path: /network-element/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_name_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_label_value_name_edit
* 
* Edit database object callback
* Path: /network-element/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_label_value_edit
* 
* Edit database object callback
* Path: /network-element/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_label_edit
* 
* Edit database object callback
* Path: /network-element/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_label_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_label_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_extension_value_name_edit
* 
* Edit database object callback
* Path: /network-element/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_extension_value_edit
* 
* Edit database object callback
* Path: /network-element/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_extension_edit
* 
* Edit database object callback
* Path: /network-element/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_network_element_extension_value_name)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_extension_edit */

/********************************************************************
* FUNCTION u_core_model_network_element_operational_state_get
* 
* Get database object callback
* Path: /network-element/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_operational_state_get (
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/network-element/operational-state");
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_network_element_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_network_element_administrative_control_edit
* 
* Edit database object callback
* Path: /network-element/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_network_element_administrative_state_get
* 
* Get database object callback
* Path: /network-element/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_administrative_state_get (
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/network-element/administrative-state");
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_network_element_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_network_element_lifecycle_state_edit
* 
* Edit database object callback
* Path: /network-element/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_network_element_edit
* 
* Edit database object callback
* Path: /network-element
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_network_element_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_network_element_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_network_element_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_layer_protocol_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/layer-protocol-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_layer_protocol_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "layer-protocol-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_layer_protocol_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_layer_protocol_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_lower_level_fc_edit
* 
* Edit database object callback
* Path: /forwarding-construct/lower-level-fc
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_lower_level_fc_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "lower-level-fc");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_lower_level_fc_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_lower_level_fc_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_route_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-route
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_route_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "fc-route");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_route_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_route_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_ltp_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/ltp
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_ltp_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "ltp");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_ltp_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_ltp_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_role_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/role
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_role_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "role");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_role_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_role_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_fc_port_direction_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/fc-port-direction
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_fc_port_direction_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "fc-port-direction");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_fc_port_direction_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_fc_port_direction_edit */


#ifdef u_core_model_F_protection_exclude_fc_port
/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_is_protection_lock_out_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/is-protection-lock-out
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_is_protection_lock_out_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "is-protection-lock-out");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", (VAL_BOOL(newval)) ? "true" : "false");

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_is_protection_lock_out_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_is_protection_lock_out_edit */
#endif /* u_core_model_F_protection_exclude_fc_port */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_selection_priority_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/selection-priority
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_selection_priority_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "selection-priority");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%ld", VAL_LONG(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_selection_priority_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_selection_priority_edit */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_is_internal_port_get
* 
* Get database object callback
* Path: /forwarding-construct/fc-port/is-internal-port
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_is_internal_port_get (
    val_value_t *dstval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid)
{
    status_t res = NO_ERR;
    xmlChar *is_internal_port;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_is_internal_port_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/forwarding-construct[uuid=\"%s\"]/fc-port[uuid=\"%s\"]/is-internal-port",
        k_forwarding_construct_uuid,
        k_forwarding_construct_fc_port_uuid);
    /* set the is_internal_port var here, */
    is_internal_port = get_value_from_xpath(xpathexpr);
    
    if (is_internal_port != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                is_internal_port);
        free(is_internal_port);
    }

    return res;

} /* u_core_model_forwarding_construct_fc_port_is_internal_port_get */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_fc_route_feeds_fc_port_egress_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/fc-route-feeds-fc-port-egress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_fc_route_feeds_fc_port_egress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "fc-route-feeds-fc-port-egress");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_fc_route_feeds_fc_port_egress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_fc_route_feeds_fc_port_egress_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_local_id_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid,
    const xmlChar *k_forwarding_construct_fc_port_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_local_id_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid,
    const xmlChar *k_forwarding_construct_fc_port_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_local_id_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid,
    const xmlChar *k_forwarding_construct_fc_port_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_uuid_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "uuid");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_name_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid,
    const xmlChar *k_forwarding_construct_fc_port_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_name_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid,
    const xmlChar *k_forwarding_construct_fc_port_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid,
    const xmlChar *k_forwarding_construct_fc_port_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_label_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid,
    const xmlChar *k_forwarding_construct_fc_port_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_label_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid,
    const xmlChar *k_forwarding_construct_fc_port_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_label_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid,
    const xmlChar *k_forwarding_construct_fc_port_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "label");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_label_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_extension_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid,
    const xmlChar *k_forwarding_construct_fc_port_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_extension_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid,
    const xmlChar *k_forwarding_construct_fc_port_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_extension_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid,
    const xmlChar *k_forwarding_construct_fc_port_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "extension");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_extension_edit */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_operational_state_get
* 
* Get database object callback
* Path: /forwarding-construct/fc-port/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/forwarding-construct[uuid=\"%s\"]/fc-port[uuid=\"%s\"]/operational-state",
        k_forwarding_construct_uuid,
        k_forwarding_construct_fc_port_uuid);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_forwarding_construct_fc_port_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_administrative_control_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "administrative-control");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_administrative_state_get
* 
* Get database object callback
* Path: /forwarding-construct/fc-port/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/forwarding-construct[uuid=\"%s\"]/fc-port[uuid=\"%s\"]/administrative-state",
        k_forwarding_construct_uuid,
        k_forwarding_construct_fc_port_uuid);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_forwarding_construct_fc_port_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_lifecycle_state_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "lifecycle-state");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_port_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-port
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_port_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "fc-port");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_port_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_hold_off_time_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/hold-off-time
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_hold_off_time_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "hold-off-time");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%ld", VAL_LONG(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_hold_off_time_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_hold_off_time_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_prot_type_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/prot-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_prot_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "prot-type");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_prot_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_prot_type_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_reversion_mode_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/reversion-mode
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_reversion_mode_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "reversion-mode");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_reversion_mode_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_reversion_mode_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_selected_fc_port_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/selected-fc-port
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_selected_fc_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "selected-fc-port");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_selected_fc_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_selected_fc_port_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_profile_proxy_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/profile-proxy
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_profile_proxy_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "profile-proxy");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_profile_proxy_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_profile_proxy_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_switch_rule_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/switch-rule
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_switch_rule_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "switch-rule");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_switch_rule_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_switch_rule_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_fc_switch_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/fc-switch
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_fc_switch_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "fc-switch");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_fc_switch_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_fc_switch_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_reversion_mode_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/control-parameters/reversion-mode
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_reversion_mode_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "reversion-mode");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_reversion_mode_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_reversion_mode_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_wait_to_revert_time_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/control-parameters/wait-to-revert-time
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_wait_to_revert_time_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "wait-to-revert-time");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%ld", VAL_LONG(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_wait_to_revert_time_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_wait_to_revert_time_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_prot_type_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/control-parameters/prot-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_prot_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "prot-type");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_prot_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_prot_type_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_hold_off_time_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/control-parameters/hold-off-time
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_hold_off_time_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "hold-off-time");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%ld", VAL_LONG(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_hold_off_time_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_hold_off_time_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_network_scheme_specification_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/control-parameters/network-scheme-specification
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_network_scheme_specification_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "network-scheme-specification");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_network_scheme_specification_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_network_scheme_specification_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/control-parameters
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "control-parameters");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_control_parameters_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_profile_proxy_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/profile-proxy
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_profile_proxy_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "profile-proxy");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_profile_proxy_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_profile_proxy_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_uuid_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "uuid");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "label");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_label_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "extension");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_extension_edit */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_operational_state_get
* 
* Get database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/forwarding-construct[uuid=\"%s\"]/fc-switch[uuid=\"%s\"]/internal-configuration-and-switch-control/local-pac/operational-state",
        k_forwarding_construct_uuid,
        k_forwarding_construct_fc_switch_uuid);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_administrative_control_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "administrative-control");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_administrative_state_get
* 
* Get database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/forwarding-construct[uuid=\"%s\"]/fc-switch[uuid=\"%s\"]/internal-configuration-and-switch-control/local-pac/administrative-state",
        k_forwarding_construct_uuid,
        k_forwarding_construct_fc_switch_uuid);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_lifecycle_state_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "lifecycle-state");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/local-pac
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-pac");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_local_pac_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_uuid_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "uuid");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "label");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_label_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "extension");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_extension_edit */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_operational_state_get
* 
* Get database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/forwarding-construct[uuid=\"%s\"]/fc-switch[uuid=\"%s\"]/internal-configuration-and-switch-control/global-pac/operational-state",
        k_forwarding_construct_uuid,
        k_forwarding_construct_fc_switch_uuid);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_administrative_control_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "administrative-control");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_administrative_state_get
* 
* Get database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/forwarding-construct[uuid=\"%s\"]/fc-switch[uuid=\"%s\"]/internal-configuration-and-switch-control/global-pac/administrative-state",
        k_forwarding_construct_uuid,
        k_forwarding_construct_fc_switch_uuid);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_lifecycle_state_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "lifecycle-state");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/global-pac
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "global-pac");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_global_pac_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_is_frozen_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/is-frozen
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_is_frozen_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "is-frozen");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", (VAL_BOOL(newval)) ? "true" : "false");

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_is_frozen_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_is_frozen_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_is_coordinated_switching_both_ends_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/is-coordinated-switching-both-ends
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_is_coordinated_switching_both_ends_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "is-coordinated-switching-both-ends");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", (VAL_BOOL(newval)) ? "true" : "false");

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_is_coordinated_switching_both_ends_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_is_coordinated_switching_both_ends_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_subordinate_controller_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control/subordinate-controller
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_subordinate_controller_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "subordinate-controller");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_subordinate_controller_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_subordinate_controller_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/internal-configuration-and-switch-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "internal-configuration-and-switch-control");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_internal_configuration_and_switch_control_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_switch_control_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/switch-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_switch_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "switch-control");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_switch_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_switch_control_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_switch_selects_ports_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/switch-selects-ports
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_switch_selects_ports_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "switch-selects-ports");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_switch_selects_ports_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_switch_selects_ports_edit */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_switch_selection_reason_get
* 
* Get database object callback
* Path: /forwarding-construct/fc-switch/switch-selection-reason
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_switch_selection_reason_get (
    val_value_t *dstval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar *switch_selection_reason;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_switch_selection_reason_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/forwarding-construct[uuid=\"%s\"]/fc-switch[uuid=\"%s\"]/switch-selection-reason",
        k_forwarding_construct_uuid,
        k_forwarding_construct_fc_switch_uuid);
    /* set the switch_selection_reason var here, */
    switch_selection_reason = get_value_from_xpath(xpathexpr);
    
    if (switch_selection_reason != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                switch_selection_reason);
        free(switch_selection_reason);
    }

    return res;

} /* u_core_model_forwarding_construct_fc_switch_switch_selection_reason_get */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_control_parameters_reversion_mode_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/control-parameters/reversion-mode
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_control_parameters_reversion_mode_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "reversion-mode");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_control_parameters_reversion_mode_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_control_parameters_reversion_mode_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_control_parameters_wait_to_revert_time_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/control-parameters/wait-to-revert-time
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_control_parameters_wait_to_revert_time_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "wait-to-revert-time");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%ld", VAL_LONG(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_control_parameters_wait_to_revert_time_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_control_parameters_wait_to_revert_time_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_control_parameters_prot_type_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/control-parameters/prot-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_control_parameters_prot_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "prot-type");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_control_parameters_prot_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_control_parameters_prot_type_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_control_parameters_hold_off_time_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/control-parameters/hold-off-time
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_control_parameters_hold_off_time_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "hold-off-time");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%ld", VAL_LONG(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_control_parameters_hold_off_time_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_control_parameters_hold_off_time_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_control_parameters_network_scheme_specification_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/control-parameters/network-scheme-specification
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_control_parameters_network_scheme_specification_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "network-scheme-specification");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_control_parameters_network_scheme_specification_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_control_parameters_network_scheme_specification_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_control_parameters_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/control-parameters
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_control_parameters_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "control-parameters");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_control_parameters_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_control_parameters_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_wait_to_restore_time_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/wait-to-restore-time
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_wait_to_restore_time_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "wait-to-restore-time");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%ld", VAL_LONG(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_wait_to_restore_time_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_wait_to_restore_time_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_local_id_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_local_id_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_local_id_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_uuid_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "uuid");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_name_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_name_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_label_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_label_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_label_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "label");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_label_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_extension_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_extension_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_extension_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "extension");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_extension_edit */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_operational_state_get
* 
* Get database object callback
* Path: /forwarding-construct/fc-switch/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/forwarding-construct[uuid=\"%s\"]/fc-switch[uuid=\"%s\"]/operational-state",
        k_forwarding_construct_uuid,
        k_forwarding_construct_fc_switch_uuid);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_forwarding_construct_fc_switch_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_administrative_control_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "administrative-control");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_administrative_state_get
* 
* Get database object callback
* Path: /forwarding-construct/fc-switch/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/forwarding-construct[uuid=\"%s\"]/fc-switch[uuid=\"%s\"]/administrative-state",
        k_forwarding_construct_uuid,
        k_forwarding_construct_fc_switch_uuid);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_forwarding_construct_fc_switch_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_lifecycle_state_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "lifecycle-state");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_fc_switch_edit
* 
* Edit database object callback
* Path: /forwarding-construct/fc-switch
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_fc_switch_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_fc_switch_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "fc-switch");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_fc_switch_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_fc_switch_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_forwarding_direction_edit
* 
* Edit database object callback
* Path: /forwarding-construct/forwarding-direction
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_forwarding_direction_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "forwarding-direction");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_forwarding_direction_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_forwarding_direction_edit */


#ifdef u_core_model_F_protection_exclude_server
/********************************************************************
* FUNCTION u_core_model_forwarding_construct_is_protection_lock_out_edit
* 
* Edit database object callback
* Path: /forwarding-construct/is-protection-lock-out
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_is_protection_lock_out_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "is-protection-lock-out");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", (VAL_BOOL(newval)) ? "true" : "false");

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_is_protection_lock_out_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_is_protection_lock_out_edit */
#endif /* u_core_model_F_protection_exclude_server */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_service_priority_edit
* 
* Edit database object callback
* Path: /forwarding-construct/service-priority
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_service_priority_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "service-priority");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%ld", VAL_LONG(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_service_priority_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_service_priority_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_supported_link_edit
* 
* Edit database object callback
* Path: /forwarding-construct/supported-link
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_supported_link_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "supported-link");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_supported_link_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_supported_link_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_local_id_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_local_id_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_local_id_edit
* 
* Edit database object callback
* Path: /forwarding-construct/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_uuid_edit
* 
* Edit database object callback
* Path: /forwarding-construct/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "uuid");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_name_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_name_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_label_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_label_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_label_edit
* 
* Edit database object callback
* Path: /forwarding-construct/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "label");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_label_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_extension_value_name_edit
* 
* Edit database object callback
* Path: /forwarding-construct/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_extension_value_edit
* 
* Edit database object callback
* Path: /forwarding-construct/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_extension_edit
* 
* Edit database object callback
* Path: /forwarding-construct/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid,
    const xmlChar *k_forwarding_construct_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "extension");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_extension_edit */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_operational_state_get
* 
* Get database object callback
* Path: /forwarding-construct/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_forwarding_construct_uuid)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/forwarding-construct[uuid=\"%s\"]/operational-state",
        k_forwarding_construct_uuid);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_forwarding_construct_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_administrative_control_edit
* 
* Edit database object callback
* Path: /forwarding-construct/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "administrative-control");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_forwarding_construct_administrative_state_get
* 
* Get database object callback
* Path: /forwarding-construct/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_forwarding_construct_uuid)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/forwarding-construct[uuid=\"%s\"]/administrative-state",
        k_forwarding_construct_uuid);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_forwarding_construct_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_lifecycle_state_edit
* 
* Edit database object callback
* Path: /forwarding-construct/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "lifecycle-state");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_forwarding_construct_edit
* 
* Edit database object callback
* Path: /forwarding-construct
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_forwarding_construct_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_forwarding_construct_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "forwarding-construct");
    sprintf(obj_id_ref, "%s",
        k_forwarding_construct_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_forwarding_construct_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_forwarding_construct_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_operation_set_after_operation_set_edit
* 
* Edit database object callback
* Path: /operation-envelope/operation-set/after-operation-set
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_operation_set_after_operation_set_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    xmlChar *k_operation_envelope_operation_set_effort_and_action)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_operation_set_after_operation_set_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_operation_set_after_operation_set_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_operation_set_before_operation_set_edit
* 
* Edit database object callback
* Path: /operation-envelope/operation-set/before-operation-set
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_operation_set_before_operation_set_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    xmlChar *k_operation_envelope_operation_set_effort_and_action)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_operation_set_before_operation_set_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_operation_set_before_operation_set_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_operation_set_effort_and_action_edit
* 
* Edit database object callback
* Path: /operation-envelope/operation-set/effort-and-action
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_operation_set_effort_and_action_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    xmlChar *k_operation_envelope_operation_set_effort_and_action)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_operation_set_effort_and_action_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_operation_set_effort_and_action_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_operation_set_pause_resume_rule_edit
* 
* Edit database object callback
* Path: /operation-envelope/operation-set/pause-resume-rule
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_operation_set_pause_resume_rule_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    xmlChar *k_operation_envelope_operation_set_effort_and_action)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_operation_set_pause_resume_rule_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_operation_set_pause_resume_rule_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_operation_set_operationset_edit
* 
* Edit database object callback
* Path: /operation-envelope/operation-set/operationset
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_operation_set_operationset_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    xmlChar *k_operation_envelope_operation_set_effort_and_action)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_operation_set_operationset_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_operation_set_operationset_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_operation_set_is_short_lived_edit
* 
* Edit database object callback
* Path: /operation-envelope/operation-set/is-short-lived
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_operation_set_is_short_lived_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    xmlChar *k_operation_envelope_operation_set_effort_and_action)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_operation_set_is_short_lived_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_operation_set_is_short_lived_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_operation_set_operation_details_action_verb_edit
* 
* Edit database object callback
* Path: /operation-envelope/operation-set/operation-details/action-verb
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_operation_set_operation_details_action_verb_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    xmlChar *k_operation_envelope_operation_set_effort_and_action,
    xmlChar *k_operation_envelope_operation_set_operation_details_action_verb)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_operation_set_operation_details_action_verb_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_operation_set_operation_details_action_verb_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_operation_set_operation_details_necessary_initialcondition_constraints_is_not_edit
* 
* Edit database object callback
* Path: /operation-envelope/operation-set/operation-details/necessary-initialcondition-constraints/is-not
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_operation_set_operation_details_necessary_initialcondition_constraints_is_not_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    xmlChar *k_operation_envelope_operation_set_effort_and_action,
    xmlChar *k_operation_envelope_operation_set_operation_details_action_verb,
    boolean k_operation_envelope_operation_set_operation_details_necessary_initialcondition_constraints_is_not)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_operation_set_operation_details_necessary_initialcondition_constraints_is_not_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_operation_set_operation_details_necessary_initialcondition_constraints_is_not_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_operation_set_operation_details_necessary_initialcondition_constraints_edit
* 
* Edit database object callback
* Path: /operation-envelope/operation-set/operation-details/necessary-initialcondition-constraints
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_operation_set_operation_details_necessary_initialcondition_constraints_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    xmlChar *k_operation_envelope_operation_set_effort_and_action,
    xmlChar *k_operation_envelope_operation_set_operation_details_action_verb,
    boolean k_operation_envelope_operation_set_operation_details_necessary_initialcondition_constraints_is_not)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_operation_set_operation_details_necessary_initialcondition_constraints_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_operation_set_operation_details_necessary_initialcondition_constraints_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_operation_set_operation_details_edit
* 
* Edit database object callback
* Path: /operation-envelope/operation-set/operation-details
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_operation_set_operation_details_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    xmlChar *k_operation_envelope_operation_set_effort_and_action,
    xmlChar *k_operation_envelope_operation_set_operation_details_action_verb)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_operation_set_operation_details_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_operation_set_operation_details_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_operation_set_edit
* 
* Edit database object callback
* Path: /operation-envelope/operation-set
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_operation_set_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    xmlChar *k_operation_envelope_operation_set_effort_and_action)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_operation_set_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_operation_set_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_generaldirectives_edit
* 
* Edit database object callback
* Path: /operation-envelope/generaldirectives
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_generaldirectives_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_generaldirectives_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_generaldirectives_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_operationidentifiers_edit
* 
* Edit database object callback
* Path: /operation-envelope/operationidentifiers
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_operationidentifiers_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_operationidentifiers_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_operationidentifiers_edit */


/********************************************************************
* FUNCTION u_core_model_operation_envelope_edit
* 
* Edit database object callback
* Path: /operation-envelope
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_operation_envelope_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_operation_envelope_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_operation_envelope_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_connector_edit
* 
* Edit database object callback
* Path: /equipment/connector/connector
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_connector_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "connector");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_connector_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_connector_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_pin_position_edit
* 
* Edit database object callback
* Path: /equipment/connector/pin/position
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_pin_position_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_pin_position)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "position");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_pin_position_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_pin_position_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_pin_orientation_edit
* 
* Edit database object callback
* Path: /equipment/connector/pin/orientation
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_pin_orientation_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_pin_position)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "orientation");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_pin_orientation_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_pin_orientation_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_pin_edit
* 
* Edit database object callback
* Path: /equipment/connector/pin
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_pin_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_pin_position)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "pin");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_pin_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_pin_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_orientation_edit
* 
* Edit database object callback
* Path: /equipment/connector/orientation
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_orientation_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "orientation");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_orientation_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_orientation_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/manufacturer-properties/manufacturer-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacturer-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_manufacturer_properties_manufacturer_name_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/manufacturer-properties/manufacturer-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_manufacturer_properties_manufacturer_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacturer-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_manufacturer_properties_manufacturer_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_manufacturer_properties_manufacturer_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_manufacturer_properties_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/manufacturer-properties
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_manufacturer_properties_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacturer-properties");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_manufacturer_properties_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_manufacturer_properties_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_equipment_type_description_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/equipment-type/description
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_equipment_type_description_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "description");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_equipment_type_description_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_equipment_type_description_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_equipment_type_model_identifier_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/equipment-type/model-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_equipment_type_model_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "model-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_equipment_type_model_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_equipment_type_model_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_equipment_type_part_type_identifier_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/equipment-type/part-type-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_equipment_type_part_type_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "part-type-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_equipment_type_part_type_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_equipment_type_part_type_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_equipment_type_type_name_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/equipment-type/type-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_equipment_type_type_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "type-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_equipment_type_type_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_equipment_type_type_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_equipment_type_version_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/equipment-type/version
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_equipment_type_version_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "version");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_equipment_type_version_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_equipment_type_version_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_equipment_type_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/equipment-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_equipment_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "equipment-type");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_equipment_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_equipment_type_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_equipment_instance_manufacture_date_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/equipment-instance/manufacture-date
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_equipment_instance_manufacture_date_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacture-date");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_equipment_instance_manufacture_date_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_equipment_instance_manufacture_date_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_equipment_instance_serial_number_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/equipment-instance/serial-number
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_equipment_instance_serial_number_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "serial-number");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_equipment_instance_serial_number_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_equipment_instance_serial_number_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_equipment_instance_asset_instance_identifier_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/equipment-instance/asset-instance-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_equipment_instance_asset_instance_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "asset-instance-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_equipment_instance_asset_instance_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_equipment_instance_asset_instance_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_equipment_instance_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/equipment-instance
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_equipment_instance_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "equipment-instance");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_equipment_instance_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_equipment_instance_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/operator-augmented-equipment-type/asset-type-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "asset-type-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_operator_augmented_equipment_type_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing/operator-augmented-equipment-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_operator_augmented_equipment_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "operator-augmented-equipment-type");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_operator_augmented_equipment_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_operator_augmented_equipment_type_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_manufactured_thing_edit
* 
* Edit database object callback
* Path: /equipment/connector/manufactured-thing
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_manufactured_thing_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufactured-thing");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_manufactured_thing_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_manufactured_thing_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_position_relative_position_edit
* 
* Edit database object callback
* Path: /equipment/connector/position/relative-position
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_position_relative_position_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "relative-position");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_position_relative_position_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_position_relative_position_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_position_edit
* 
* Edit database object callback
* Path: /equipment/connector/position
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_position_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "position");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_position_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_position_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_mechanical_features_edit
* 
* Edit database object callback
* Path: /equipment/connector/mechanical-features
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_mechanical_features_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "mechanical-features");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_mechanical_features_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_mechanical_features_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_pin_layout_position_relative_position_edit
* 
* Edit database object callback
* Path: /equipment/connector/pin-layout/position/relative-position
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_pin_layout_position_relative_position_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_pin_layout_position_relative_position)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "relative-position");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_pin_layout_position_relative_position_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_pin_layout_position_relative_position_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_pin_layout_position_edit
* 
* Edit database object callback
* Path: /equipment/connector/pin-layout/position
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_pin_layout_position_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_pin_layout_position_relative_position)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "position");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_pin_layout_position_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_pin_layout_position_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_pin_layout_edit
* 
* Edit database object callback
* Path: /equipment/connector/pin-layout
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_pin_layout_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "pin-layout");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_pin_layout_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_pin_layout_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_connector_type_edit
* 
* Edit database object callback
* Path: /equipment/connector/connector-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_connector_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "connector-type");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_connector_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_connector_type_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_local_id_value_name_edit
* 
* Edit database object callback
* Path: /equipment/connector/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_local_id_value_edit
* 
* Edit database object callback
* Path: /equipment/connector/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_local_id_edit
* 
* Edit database object callback
* Path: /equipment/connector/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_uuid_edit
* 
* Edit database object callback
* Path: /equipment/connector/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "uuid");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_name_value_name_edit
* 
* Edit database object callback
* Path: /equipment/connector/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_name_value_edit
* 
* Edit database object callback
* Path: /equipment/connector/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_name_edit
* 
* Edit database object callback
* Path: /equipment/connector/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_label_value_name_edit
* 
* Edit database object callback
* Path: /equipment/connector/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_label_value_edit
* 
* Edit database object callback
* Path: /equipment/connector/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_label_edit
* 
* Edit database object callback
* Path: /equipment/connector/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "label");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_label_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_extension_value_name_edit
* 
* Edit database object callback
* Path: /equipment/connector/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_extension_value_edit
* 
* Edit database object callback
* Path: /equipment/connector/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_extension_edit
* 
* Edit database object callback
* Path: /equipment/connector/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid,
    const xmlChar *k_equipment_connector_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "extension");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_extension_edit */

/********************************************************************
* FUNCTION u_core_model_equipment_connector_operational_state_get
* 
* Get database object callback
* Path: /equipment/connector/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/equipment[uuid=\"%s\"]/connector[uuid=\"%s\"]/operational-state",
        k_equipment_uuid,
        k_equipment_connector_uuid);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_equipment_connector_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_administrative_control_edit
* 
* Edit database object callback
* Path: /equipment/connector/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "administrative-control");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_equipment_connector_administrative_state_get
* 
* Get database object callback
* Path: /equipment/connector/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/equipment[uuid=\"%s\"]/connector[uuid=\"%s\"]/administrative-state",
        k_equipment_uuid,
        k_equipment_connector_uuid);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_equipment_connector_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_lifecycle_state_edit
* 
* Edit database object callback
* Path: /equipment/connector/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "lifecycle-state");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_connector_edit
* 
* Edit database object callback
* Path: /equipment/connector
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_connector_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "connector");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_connector_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_connector_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_connector_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/connector
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_connector_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "connector");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_connector_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_connector_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_occupying_fru_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/occupying-fru
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_occupying_fru_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "occupying-fru");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_occupying_fru_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_occupying_fru_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_spatial_properties_of_type_height_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/spatial-properties-of-type/height
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_spatial_properties_of_type_height_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "height");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_spatial_properties_of_type_height_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_spatial_properties_of_type_height_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_spatial_properties_of_type_width_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/spatial-properties-of-type/width
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_spatial_properties_of_type_width_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "width");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_spatial_properties_of_type_width_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_spatial_properties_of_type_width_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_spatial_properties_of_type_length_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/spatial-properties-of-type/length
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_spatial_properties_of_type_length_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "length");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_spatial_properties_of_type_length_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_spatial_properties_of_type_length_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_spatial_properties_of_type_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/spatial-properties-of-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_spatial_properties_of_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "spatial-properties-of-type");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_spatial_properties_of_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_spatial_properties_of_type_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_monitors_is_active_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-monitors/is-active
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_monitors_is_active_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "is-active");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", (VAL_BOOL(newval)) ? "true" : "false");

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_monitors_is_active_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_monitors_is_active_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_monitors_is_actual_mismatch_with_expected_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-monitors/is-actual-mismatch-with-expected
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_monitors_is_actual_mismatch_with_expected_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "is-actual-mismatch-with-expected");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", (VAL_BOOL(newval)) ? "true" : "false");

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_monitors_is_actual_mismatch_with_expected_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_monitors_is_actual_mismatch_with_expected_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_monitors_aggregate_function_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-monitors/aggregate-function
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_monitors_aggregate_function_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "aggregate-function");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_monitors_aggregate_function_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_monitors_aggregate_function_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_monitors_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-monitors
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_monitors_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "holder-monitors");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_monitors_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_monitors_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_name_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "address-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_address_element_name_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element/address-element-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_address_element_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "address-element-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_address_element_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_address_element_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_local_id_class_of_instance_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element/local-id/class-of-instance
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_local_id_class_of_instance_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "class-of-instance");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_local_id_class_of_instance_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_local_id_class_of_instance_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_local_id_local_id_value_name_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element/local-id/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_local_id_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_local_id_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_local_id_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_local_id_local_id_value_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element/local-id/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_local_id_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_local_id_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_local_id_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_local_id_local_id_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element/local-id/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_local_id_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_local_id_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_local_id_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_local_id_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_uuid_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "uuid");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_name_class_of_instance_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element/name/class-of-instance
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_name_class_of_instance_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "class-of-instance");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_name_class_of_instance_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_name_class_of_instance_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_name_name_value_name_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element/name/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_name_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_name_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_name_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_name_name_value_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element/name/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_name_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_name_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_name_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_name_name_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element/name/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_name_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_name_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_name_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_name_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_arbitrary_element_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element/arbitrary-element
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_arbitrary_element_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "arbitrary-element");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_arbitrary_element_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_arbitrary_element_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_address_element_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location/address-element
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_address_element_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_holder_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "address-element");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_address_element_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_address_element_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_location_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-location
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_location_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "holder-location");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_location_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_location_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_position_relative_position_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/position/relative-position
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_position_relative_position_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "relative-position");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_position_relative_position_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_position_relative_position_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_position_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/position
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_position_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "position");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_position_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_position_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_structure_holder_category_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-structure/holder-category
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_structure_holder_category_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "holder-category");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_structure_holder_category_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_structure_holder_category_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_structure_is_captive_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-structure/is-captive
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_structure_is_captive_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "is-captive");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", (VAL_BOOL(newval)) ? "true" : "false");

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_structure_is_captive_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_structure_is_captive_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_structure_is_guided_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-structure/is-guided
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_structure_is_guided_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "is-guided");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", (VAL_BOOL(newval)) ? "true" : "false");

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_structure_is_guided_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_structure_is_guided_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_structure_is_quantized_space_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-structure/is-quantized-space
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_structure_is_quantized_space_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "is-quantized-space");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", (VAL_BOOL(newval)) ? "true" : "false");

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_structure_is_quantized_space_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_structure_is_quantized_space_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_holder_structure_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/holder-structure
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_holder_structure_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "holder-structure");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_holder_structure_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_holder_structure_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_physical_rating_thermal_rating_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/physical-rating/thermal-rating
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_physical_rating_thermal_rating_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "thermal-rating");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_physical_rating_thermal_rating_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_physical_rating_thermal_rating_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_physical_rating_power_rating_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/physical-rating/power-rating
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_physical_rating_power_rating_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "power-rating");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_physical_rating_power_rating_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_physical_rating_power_rating_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_physical_rating_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/physical-rating
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_physical_rating_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "physical-rating");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_physical_rating_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_physical_rating_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_supported_equipment_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/supported-equipment
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_supported_equipment_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "supported-equipment");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_supported_equipment_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_supported_equipment_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_expected_holder_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/expected-holder
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_expected_holder_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "expected-holder");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_expected_holder_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_expected_holder_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_actual_holder_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/actual-holder
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_actual_holder_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "actual-holder");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_actual_holder_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_actual_holder_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_local_id_value_name_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_local_id_value_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_local_id_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_uuid_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "uuid");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_name_value_name_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_name_value_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_name_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_label_value_name_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_label_value_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_label_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "label");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_label_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_extension_value_name_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_extension_value_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_extension_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid,
    const xmlChar *k_equipment_contained_holder_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "extension");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_extension_edit */

/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_operational_state_get
* 
* Get database object callback
* Path: /equipment/contained-holder/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/equipment[uuid=\"%s\"]/contained-holder[uuid=\"%s\"]/operational-state",
        k_equipment_uuid,
        k_equipment_contained_holder_uuid);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_equipment_contained_holder_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_administrative_control_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "administrative-control");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_administrative_state_get
* 
* Get database object callback
* Path: /equipment/contained-holder/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/equipment[uuid=\"%s\"]/contained-holder[uuid=\"%s\"]/administrative-state",
        k_equipment_uuid,
        k_equipment_contained_holder_uuid);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_equipment_contained_holder_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_lifecycle_state_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "lifecycle-state");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_contained_holder_edit
* 
* Edit database object callback
* Path: /equipment/contained-holder
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_contained_holder_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_contained_holder_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "contained-holder");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_contained_holder_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_contained_holder_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_connector_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/connector
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_connector_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "connector");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_connector_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_connector_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_pin_position_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/pin/position
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_pin_position_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_pin_position)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "position");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_pin_position_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_pin_position_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_pin_orientation_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/pin/orientation
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_pin_orientation_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_pin_position)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "orientation");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_pin_orientation_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_pin_orientation_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_pin_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/pin
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_pin_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_pin_position)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "pin");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_pin_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_pin_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_orientation_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/orientation
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_orientation_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "orientation");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_orientation_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_orientation_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/manufacturer-properties/manufacturer-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacturer-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_manufacturer_properties_manufacturer_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/manufacturer-properties/manufacturer-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_manufacturer_properties_manufacturer_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacturer-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_manufacturer_properties_manufacturer_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_manufacturer_properties_manufacturer_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_manufacturer_properties_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/manufacturer-properties
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_manufacturer_properties_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacturer-properties");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_manufacturer_properties_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_manufacturer_properties_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_description_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/equipment-type/description
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_description_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "description");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_description_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_description_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_model_identifier_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/equipment-type/model-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_model_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "model-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_model_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_model_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_part_type_identifier_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/equipment-type/part-type-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_part_type_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "part-type-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_part_type_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_part_type_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_type_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/equipment-type/type-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_type_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "type-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_type_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_type_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_version_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/equipment-type/version
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_version_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "version");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_version_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_version_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/equipment-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "equipment-type");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_type_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_manufacture_date_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/equipment-instance/manufacture-date
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_manufacture_date_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacture-date");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_manufacture_date_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_manufacture_date_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_serial_number_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/equipment-instance/serial-number
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_serial_number_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "serial-number");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_serial_number_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_serial_number_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_asset_instance_identifier_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/equipment-instance/asset-instance-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_asset_instance_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "asset-instance-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_asset_instance_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_asset_instance_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/equipment-instance
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "equipment-instance");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_equipment_instance_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/operator-augmented-equipment-type/asset-type-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "asset-type-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_operator_augmented_equipment_type_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing/operator-augmented-equipment-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_operator_augmented_equipment_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "operator-augmented-equipment-type");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_operator_augmented_equipment_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_operator_augmented_equipment_type_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_manufactured_thing_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/manufactured-thing
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_manufactured_thing_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufactured-thing");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_manufactured_thing_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_manufactured_thing_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_position_relative_position_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/position/relative-position
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_position_relative_position_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "relative-position");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_position_relative_position_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_position_relative_position_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_position_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/position
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_position_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "position");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_position_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_position_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_mechanical_features_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/mechanical-features
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_mechanical_features_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "mechanical-features");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_mechanical_features_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_mechanical_features_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_pin_layout_position_relative_position_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/pin-layout/position/relative-position
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_pin_layout_position_relative_position_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_pin_layout_position_relative_position)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "relative-position");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_pin_layout_position_relative_position_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_pin_layout_position_relative_position_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_pin_layout_position_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/pin-layout/position
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_pin_layout_position_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_pin_layout_position_relative_position)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "position");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_pin_layout_position_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_pin_layout_position_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_pin_layout_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/pin-layout
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_pin_layout_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "pin-layout");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_pin_layout_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_pin_layout_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_connector_type_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/connector-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_connector_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "connector-type");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_connector_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_connector_type_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_local_id_value_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_local_id_value_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_local_id_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_uuid_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "uuid");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_name_value_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_name_value_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_label_value_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_label_value_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_label_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "label");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_label_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_extension_value_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_extension_value_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_extension_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "extension");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_extension_edit */

/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_operational_state_get
* 
* Get database object callback
* Path: /equipment/exposed-cable/connector/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/equipment[uuid=\"%s\"]/exposed-cable[uuid=\"%s\"]/connector[uuid=\"%s\"]/operational-state",
        k_equipment_uuid,
        k_equipment_exposed_cable_uuid,
        k_equipment_exposed_cable_connector_uuid);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_equipment_exposed_cable_connector_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_administrative_control_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "administrative-control");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_administrative_state_get
* 
* Get database object callback
* Path: /equipment/exposed-cable/connector/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/equipment[uuid=\"%s\"]/exposed-cable[uuid=\"%s\"]/connector[uuid=\"%s\"]/administrative-state",
        k_equipment_uuid,
        k_equipment_exposed_cable_uuid,
        k_equipment_exposed_cable_connector_uuid);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_equipment_exposed_cable_connector_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_lifecycle_state_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "lifecycle-state");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_connector_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/connector
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_connector_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_connector_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "connector");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_connector_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_connector_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/manufacturer-properties/manufacturer-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacturer-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_manufacturer_properties_manufacturer_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/manufacturer-properties/manufacturer-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_manufacturer_properties_manufacturer_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacturer-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_manufacturer_properties_manufacturer_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_manufacturer_properties_manufacturer_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_manufacturer_properties_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/manufacturer-properties
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_manufacturer_properties_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacturer-properties");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_manufacturer_properties_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_manufacturer_properties_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_description_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/equipment-type/description
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_description_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "description");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_description_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_description_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_model_identifier_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/equipment-type/model-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_model_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "model-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_model_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_model_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_part_type_identifier_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/equipment-type/part-type-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_part_type_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "part-type-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_part_type_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_part_type_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_type_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/equipment-type/type-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_type_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "type-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_type_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_type_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_version_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/equipment-type/version
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_version_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "version");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_version_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_version_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/equipment-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "equipment-type");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_equipment_type_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_manufacture_date_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/equipment-instance/manufacture-date
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_manufacture_date_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacture-date");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_manufacture_date_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_manufacture_date_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_serial_number_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/equipment-instance/serial-number
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_serial_number_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "serial-number");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_serial_number_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_serial_number_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_asset_instance_identifier_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/equipment-instance/asset-instance-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_asset_instance_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "asset-instance-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_asset_instance_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_asset_instance_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/equipment-instance
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "equipment-instance");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_equipment_instance_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/operator-augmented-equipment-type/asset-type-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "asset-type-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_operator_augmented_equipment_type_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing/operator-augmented-equipment-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_operator_augmented_equipment_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "operator-augmented-equipment-type");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_operator_augmented_equipment_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_operator_augmented_equipment_type_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_manufactured_thing_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/manufactured-thing
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_manufactured_thing_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufactured-thing");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_manufactured_thing_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_manufactured_thing_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_physical_characteristics_weight_characteristics_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/physical-characteristics/weight-characteristics
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_physical_characteristics_weight_characteristics_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "weight-characteristics");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_physical_characteristics_weight_characteristics_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_physical_characteristics_weight_characteristics_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_physical_characteristics_fire_characteristics_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/physical-characteristics/fire-characteristics
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_physical_characteristics_fire_characteristics_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "fire-characteristics");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_physical_characteristics_fire_characteristics_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_physical_characteristics_fire_characteristics_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_physical_characteristics_materials_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/physical-characteristics/materials
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_physical_characteristics_materials_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "materials");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_physical_characteristics_materials_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_physical_characteristics_materials_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_physical_characteristics_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/physical-characteristics
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_physical_characteristics_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "physical-characteristics");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_physical_characteristics_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_physical_characteristics_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_mechanical_features_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/mechanical-features
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_mechanical_features_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "mechanical-features");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_mechanical_features_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_mechanical_features_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_spatial_properties_of_type_height_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/spatial-properties-of-type/height
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_spatial_properties_of_type_height_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "height");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_spatial_properties_of_type_height_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_spatial_properties_of_type_height_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_spatial_properties_of_type_width_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/spatial-properties-of-type/width
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_spatial_properties_of_type_width_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "width");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_spatial_properties_of_type_width_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_spatial_properties_of_type_width_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_spatial_properties_of_type_length_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/spatial-properties-of-type/length
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_spatial_properties_of_type_length_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "length");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_spatial_properties_of_type_length_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_spatial_properties_of_type_length_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_spatial_properties_of_type_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/spatial-properties-of-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_spatial_properties_of_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "spatial-properties-of-type");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_spatial_properties_of_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_spatial_properties_of_type_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_local_id_value_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_local_id_value_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_local_id_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_uuid_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "uuid");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_name_value_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_name_value_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_label_value_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_label_value_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_label_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "label");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_label_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_extension_value_name_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_extension_value_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_extension_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid,
    const xmlChar *k_equipment_exposed_cable_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "extension");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_extension_edit */

/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_operational_state_get
* 
* Get database object callback
* Path: /equipment/exposed-cable/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/equipment[uuid=\"%s\"]/exposed-cable[uuid=\"%s\"]/operational-state",
        k_equipment_uuid,
        k_equipment_exposed_cable_uuid);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_equipment_exposed_cable_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_administrative_control_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "administrative-control");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_administrative_state_get
* 
* Get database object callback
* Path: /equipment/exposed-cable/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/equipment[uuid=\"%s\"]/exposed-cable[uuid=\"%s\"]/administrative-state",
        k_equipment_uuid,
        k_equipment_exposed_cable_uuid);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_equipment_exposed_cable_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_lifecycle_state_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "lifecycle-state");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_exposed_cable_edit
* 
* Edit database object callback
* Path: /equipment/exposed-cable
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_exposed_cable_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_exposed_cable_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "exposed-cable");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_exposed_cable_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_exposed_cable_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/manufacturer-properties/manufacturer-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacturer-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_manufacturer_properties_manufacturer_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_manufacturer_properties_manufacturer_name_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/manufacturer-properties/manufacturer-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_manufacturer_properties_manufacturer_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacturer-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_manufacturer_properties_manufacturer_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_manufacturer_properties_manufacturer_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_manufacturer_properties_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/manufacturer-properties
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_manufacturer_properties_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacturer-properties");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_manufacturer_properties_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_manufacturer_properties_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_equipment_type_description_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/equipment-type/description
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_equipment_type_description_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "description");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_equipment_type_description_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_equipment_type_description_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_equipment_type_model_identifier_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/equipment-type/model-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_equipment_type_model_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "model-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_equipment_type_model_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_equipment_type_model_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_equipment_type_part_type_identifier_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/equipment-type/part-type-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_equipment_type_part_type_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "part-type-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_equipment_type_part_type_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_equipment_type_part_type_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_equipment_type_type_name_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/equipment-type/type-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_equipment_type_type_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "type-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_equipment_type_type_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_equipment_type_type_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_equipment_type_version_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/equipment-type/version
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_equipment_type_version_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "version");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_equipment_type_version_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_equipment_type_version_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_equipment_type_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/equipment-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_equipment_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "equipment-type");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_equipment_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_equipment_type_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_equipment_instance_manufacture_date_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/equipment-instance/manufacture-date
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_equipment_instance_manufacture_date_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufacture-date");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_equipment_instance_manufacture_date_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_equipment_instance_manufacture_date_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_equipment_instance_serial_number_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/equipment-instance/serial-number
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_equipment_instance_serial_number_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "serial-number");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_equipment_instance_serial_number_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_equipment_instance_serial_number_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_equipment_instance_asset_instance_identifier_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/equipment-instance/asset-instance-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_equipment_instance_asset_instance_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "asset-instance-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_equipment_instance_asset_instance_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_equipment_instance_asset_instance_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_equipment_instance_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/equipment-instance
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_equipment_instance_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "equipment-instance");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_equipment_instance_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_equipment_instance_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/operator-augmented-equipment-type/asset-type-identifier
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "asset-type-identifier");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_operator_augmented_equipment_type_asset_type_identifier_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_operator_augmented_equipment_type_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing/operator-augmented-equipment-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_operator_augmented_equipment_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "operator-augmented-equipment-type");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_operator_augmented_equipment_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_operator_augmented_equipment_type_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_manufactured_thing_edit
* 
* Edit database object callback
* Path: /equipment/manufactured-thing
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_manufactured_thing_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "manufactured-thing");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_manufactured_thing_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_manufactured_thing_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_spatial_properties_of_type_height_edit
* 
* Edit database object callback
* Path: /equipment/spatial-properties-of-type/height
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_spatial_properties_of_type_height_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "height");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_spatial_properties_of_type_height_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_spatial_properties_of_type_height_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_spatial_properties_of_type_width_edit
* 
* Edit database object callback
* Path: /equipment/spatial-properties-of-type/width
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_spatial_properties_of_type_width_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "width");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_spatial_properties_of_type_width_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_spatial_properties_of_type_width_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_spatial_properties_of_type_length_edit
* 
* Edit database object callback
* Path: /equipment/spatial-properties-of-type/length
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_spatial_properties_of_type_length_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "length");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_spatial_properties_of_type_length_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_spatial_properties_of_type_length_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_spatial_properties_of_type_edit
* 
* Edit database object callback
* Path: /equipment/spatial-properties-of-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_spatial_properties_of_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "spatial-properties-of-type");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_spatial_properties_of_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_spatial_properties_of_type_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_mechanical_features_edit
* 
* Edit database object callback
* Path: /equipment/mechanical-features
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_mechanical_features_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "mechanical-features");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_mechanical_features_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_mechanical_features_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_physical_properties_temperature_edit
* 
* Edit database object callback
* Path: /equipment/physical-properties/temperature
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_physical_properties_temperature_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "temperature");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_physical_properties_temperature_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_physical_properties_temperature_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_physical_properties_edit
* 
* Edit database object callback
* Path: /equipment/physical-properties
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_physical_properties_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "physical-properties");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_physical_properties_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_physical_properties_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_function_enablers_power_state_edit
* 
* Edit database object callback
* Path: /equipment/function-enablers/power-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_function_enablers_power_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "power-state");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_function_enablers_power_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_function_enablers_power_state_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_function_enablers_edit
* 
* Edit database object callback
* Path: /equipment/function-enablers
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_function_enablers_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "function-enablers");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_function_enablers_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_function_enablers_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_mechanical_functions_rotation_speed_edit
* 
* Edit database object callback
* Path: /equipment/mechanical-functions/rotation-speed
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_mechanical_functions_rotation_speed_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "rotation-speed");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_mechanical_functions_rotation_speed_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_mechanical_functions_rotation_speed_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_mechanical_functions_edit
* 
* Edit database object callback
* Path: /equipment/mechanical-functions
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_mechanical_functions_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "mechanical-functions");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_mechanical_functions_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_mechanical_functions_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_physical_characteristics_weight_characteristics_edit
* 
* Edit database object callback
* Path: /equipment/physical-characteristics/weight-characteristics
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_physical_characteristics_weight_characteristics_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "weight-characteristics");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_physical_characteristics_weight_characteristics_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_physical_characteristics_weight_characteristics_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_physical_characteristics_fire_characteristics_edit
* 
* Edit database object callback
* Path: /equipment/physical-characteristics/fire-characteristics
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_physical_characteristics_fire_characteristics_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "fire-characteristics");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_physical_characteristics_fire_characteristics_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_physical_characteristics_fire_characteristics_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_physical_characteristics_materials_edit
* 
* Edit database object callback
* Path: /equipment/physical-characteristics/materials
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_physical_characteristics_materials_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "materials");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_physical_characteristics_materials_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_physical_characteristics_materials_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_physical_characteristics_edit
* 
* Edit database object callback
* Path: /equipment/physical-characteristics
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_physical_characteristics_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "physical-characteristics");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_physical_characteristics_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_physical_characteristics_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_swapability_is_hot_swappable_edit
* 
* Edit database object callback
* Path: /equipment/swapability/is-hot-swappable
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_swapability_is_hot_swappable_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "is-hot-swappable");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", (VAL_BOOL(newval)) ? "true" : "false");

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_swapability_is_hot_swappable_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_swapability_is_hot_swappable_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_swapability_edit
* 
* Edit database object callback
* Path: /equipment/swapability
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_swapability_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "swapability");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_swapability_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_swapability_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_category_category_edit
* 
* Edit database object callback
* Path: /equipment/category/category
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_category_category_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "category");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_category_category_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_category_category_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_category_edit
* 
* Edit database object callback
* Path: /equipment/category
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_category_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "category");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_category_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_category_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_physical_rating_thermal_rating_edit
* 
* Edit database object callback
* Path: /equipment/physical-rating/thermal-rating
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_physical_rating_thermal_rating_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "thermal-rating");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_physical_rating_thermal_rating_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_physical_rating_thermal_rating_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_physical_rating_power_rating_edit
* 
* Edit database object callback
* Path: /equipment/physical-rating/power-rating
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_physical_rating_power_rating_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "power-rating");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_physical_rating_power_rating_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_physical_rating_power_rating_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_physical_rating_edit
* 
* Edit database object callback
* Path: /equipment/physical-rating
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_physical_rating_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "physical-rating");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_physical_rating_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_physical_rating_edit */

/********************************************************************
* FUNCTION u_core_model_equipment_is_field_replaceable_get
* 
* Get database object callback
* Path: /equipment/is-field-replaceable
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_is_field_replaceable_get (
    val_value_t *dstval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar *is_field_replaceable;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_is_field_replaceable_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/equipment[uuid=\"%s\"]/is-field-replaceable",
        k_equipment_uuid);
    /* set the is_field_replaceable var here, replace (void) or use default value */
    is_field_replaceable = get_value_from_xpath(xpathexpr);
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        (is_field_replaceable) != NULL ? is_field_replaceable : (const xmlChar *)"true");
    
    if (is_field_replaceable != NULL)
    {
        free(is_field_replaceable);
    }

    return res;

} /* u_core_model_equipment_is_field_replaceable_get */


/********************************************************************
* FUNCTION u_core_model_equipment_function_block_edit
* 
* Edit database object callback
* Path: /equipment/function-block
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_function_block_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "function-block");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_function_block_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_function_block_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_expected_equipment_edit
* 
* Edit database object callback
* Path: /equipment/expected-equipment
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_expected_equipment_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "expected-equipment");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_expected_equipment_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_expected_equipment_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_actual_equipment_edit
* 
* Edit database object callback
* Path: /equipment/actual-equipment
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_actual_equipment_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "actual-equipment");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_actual_equipment_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_actual_equipment_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_name_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "address-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_address_element_name_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element/address-element-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_address_element_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "address-element-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_address_element_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_address_element_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_local_id_class_of_instance_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element/local-id/class-of-instance
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_local_id_class_of_instance_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "class-of-instance");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_local_id_class_of_instance_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_local_id_class_of_instance_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_local_id_local_id_value_name_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element/local-id/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_local_id_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_local_id_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_local_id_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_local_id_local_id_value_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element/local-id/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_local_id_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_local_id_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_local_id_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_local_id_local_id_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element/local-id/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_local_id_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_local_id_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_local_id_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_local_id_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_uuid_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "uuid");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_name_class_of_instance_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element/name/class-of-instance
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_name_class_of_instance_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "class-of-instance");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_name_class_of_instance_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_name_class_of_instance_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_name_name_value_name_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element/name/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_name_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_name_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_name_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_name_name_value_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element/name/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_name_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_name_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_name_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_name_name_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element/name/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_name_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_name_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_name_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_name_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_arbitrary_element_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element/arbitrary-element
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_arbitrary_element_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "arbitrary-element");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_arbitrary_element_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_arbitrary_element_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_address_element_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location/address-element
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_address_element_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_equipment_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "address-element");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_address_element_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_address_element_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_equipment_location_edit
* 
* Edit database object callback
* Path: /equipment/location/equipment-location
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_equipment_location_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "equipment-location");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_equipment_location_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_equipment_location_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_name_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "address-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_address_element_name_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element/address-element-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_address_element_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "address-element-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_address_element_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_address_element_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_local_id_class_of_instance_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element/local-id/class-of-instance
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_local_id_class_of_instance_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "class-of-instance");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_local_id_class_of_instance_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_local_id_class_of_instance_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_local_id_local_id_value_name_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element/local-id/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_local_id_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_local_id_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_local_id_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_local_id_local_id_value_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element/local-id/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_local_id_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_local_id_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_local_id_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_local_id_local_id_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element/local-id/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_local_id_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_local_id_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_local_id_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_local_id_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_uuid_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "uuid");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_name_class_of_instance_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element/name/class-of-instance
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_name_class_of_instance_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "class-of-instance");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_name_class_of_instance_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_name_class_of_instance_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_name_name_value_name_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element/name/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_name_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_name_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_name_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_name_name_value_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element/name/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_name_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_name_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_name_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_name_name_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element/name/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_name_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_name_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_name_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_name_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_arbitrary_element_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element/arbitrary-element
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_arbitrary_element_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "arbitrary-element");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_arbitrary_element_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_arbitrary_element_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_address_element_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location/address-element
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_address_element_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_location_geographical_location_address_element_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "address-element");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_address_element_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_address_element_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_geographical_location_edit
* 
* Edit database object callback
* Path: /equipment/location/geographical-location
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_geographical_location_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "geographical-location");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_geographical_location_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_geographical_location_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_location_edit
* 
* Edit database object callback
* Path: /equipment/location
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_location_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "location");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_location_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_location_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_local_id_value_name_edit
* 
* Edit database object callback
* Path: /equipment/local-id/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_local_id_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_local_id_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_local_id_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_local_id_value_edit
* 
* Edit database object callback
* Path: /equipment/local-id/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_local_id_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_local_id_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_local_id_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_local_id_edit
* 
* Edit database object callback
* Path: /equipment/local-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_local_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_local_id_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "local-id");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_local_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_local_id_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_uuid_edit
* 
* Edit database object callback
* Path: /equipment/uuid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_uuid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "uuid");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_uuid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_uuid_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_name_value_name_edit
* 
* Edit database object callback
* Path: /equipment/name/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_name_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_name_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_name_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_name_value_edit
* 
* Edit database object callback
* Path: /equipment/name/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_name_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_name_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_name_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_name_edit
* 
* Edit database object callback
* Path: /equipment/name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_name_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_label_value_name_edit
* 
* Edit database object callback
* Path: /equipment/label/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_label_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_label_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_label_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_label_value_edit
* 
* Edit database object callback
* Path: /equipment/label/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_label_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_label_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_label_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_label_edit
* 
* Edit database object callback
* Path: /equipment/label
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_label_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_label_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "label");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_label_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_label_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_extension_value_name_edit
* 
* Edit database object callback
* Path: /equipment/extension/value-name
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_extension_value_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value-name");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_extension_value_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_extension_value_name_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_extension_value_edit
* 
* Edit database object callback
* Path: /equipment/extension/value
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_extension_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "value");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_extension_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_extension_value_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_extension_edit
* 
* Edit database object callback
* Path: /equipment/extension
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_extension_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid,
    const xmlChar *k_equipment_extension_value_name)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "extension");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_extension_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_extension_edit */

/********************************************************************
* FUNCTION u_core_model_equipment_operational_state_get
* 
* Get database object callback
* Path: /equipment/operational-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_operational_state_get (
    val_value_t *dstval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar *operational_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_operational_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/equipment[uuid=\"%s\"]/operational-state",
        k_equipment_uuid);
    /* set the operational_state var here, */
    operational_state = get_value_from_xpath(xpathexpr);
    
    if (operational_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                operational_state);
        free(operational_state);
    }

    return res;

} /* u_core_model_equipment_operational_state_get */


/********************************************************************
* FUNCTION u_core_model_equipment_administrative_control_edit
* 
* Edit database object callback
* Path: /equipment/administrative-control
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_administrative_control_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "administrative-control");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_administrative_control_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_administrative_control_edit */

/********************************************************************
* FUNCTION u_core_model_equipment_administrative_state_get
* 
* Get database object callback
* Path: /equipment/administrative-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_administrative_state_get (
    val_value_t *dstval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar *administrative_state;

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_administrative_state_get callback");
    }


    xmlChar *xpathexpr[XPATH_MAX_LENGTH];
    sprintf(xpathexpr, "/equipment[uuid=\"%s\"]/administrative-state",
        k_equipment_uuid);
    /* set the administrative_state var here, */
    administrative_state = get_value_from_xpath(xpathexpr);
    
    if (administrative_state != NULL)
    {
        res = val_set_simval_obj(
                dstval,
                dstval->obj,
                administrative_state);
        free(administrative_state);
    }

    return res;

} /* u_core_model_equipment_administrative_state_get */


/********************************************************************
* FUNCTION u_core_model_equipment_lifecycle_state_edit
* 
* Edit database object callback
* Path: /equipment/lifecycle-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_lifecycle_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "lifecycle-state");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);
    sprintf(new_value, "%s", VAL_STR(newval));

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_lifecycle_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_lifecycle_state_edit */


/********************************************************************
* FUNCTION u_core_model_equipment_edit
* 
* Edit database object callback
* Path: /equipment
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_equipment_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_equipment_uuid)
{
    status_t res = NO_ERR;
    xmlChar dateAndTime[256];
    time_t t = time(NULL);
    struct tm tm = *localtime(&t);
    struct timeval tv;
    int millisec;
    xmlChar *obj_id_ref[XPATH_MAX_LENGTH];
    xmlChar *attr_name[XPATH_MAX_LENGTH];
    xmlChar* new_value[XPATH_MAX_LENGTH];
    
    gettimeofday(&tv, NULL);
    millisec = lrint(tv.tv_usec/1000.0); // Round to nearest millisec
    if (millisec>=1000)
    { // Allow for rounding up to nearest second
        millisec -=1000;
        tv.tv_sec++;
        millisec /= 100;
    }
    sprintf(dateAndTime, "%04d-%02d-%02dT%02d:%02d:%02d.%01dZ",
    tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
    tm.tm_hour, tm.tm_min, tm.tm_sec, millisec/100);
    sprintf(attr_name, "equipment");
    sprintf(obj_id_ref, "%s",
        k_equipment_uuid);

    if (LOGDEBUG) {
        log_debug("\nEnter u_core_model_equipment_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_REPLACE:
            u_microwave_model_attribute_value_changed_notification_send(attribute_value_changed_counter++,
            dateAndTime, obj_id_ref, attr_name, new_value);
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_core_model_equipment_edit */

/********************************************************************
* FUNCTION u_core_model_init
* 
* initialize the core-model server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;
    ncx_module_t *core_model_mod = NULL;

#ifdef u_core_model_F_protection_exclude_server
    ncx_set_feature_enable(
        y_core_model_M_core_model,
        (const xmlChar *)"protection-exclude-server",
        TRUE);
#else
    ncx_set_feature_enable(
        y_core_model_M_core_model,
        (const xmlChar *)"protection-exclude-server",
        FALSE);
#endif

#ifdef u_core_model_F_protection_exclude_fc_port
    ncx_set_feature_enable(
        y_core_model_M_core_model,
        (const xmlChar *)"protection-exclude-fc-port",
        TRUE);
#else
    ncx_set_feature_enable(
        y_core_model_M_core_model,
        (const xmlChar *)"protection-exclude-fc-port",
        FALSE);
#endif

#ifdef u_core_model_F_protection_exclude_ltp
    ncx_set_feature_enable(
        y_core_model_M_core_model,
        (const xmlChar *)"protection-exclude-ltp",
        TRUE);
#else
    ncx_set_feature_enable(
        y_core_model_M_core_model,
        (const xmlChar *)"protection-exclude-ltp",
        FALSE);
#endif

    core_model_mod = ncx_find_module(
        y_core_model_M_core_model,
        y_core_model_R_core_model);
    if (core_model_mod == NULL) {
        return ERR_NCX_OPERATION_FAILED;
    }
    /* put your module initialization code here */
    
    return res;
} /* u_core_model_init */

/********************************************************************
* FUNCTION u_core_model_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
status_t u_core_model_init2 (void)
{
    status_t res = NO_ERR;

    /* put your init2 code here */

    return res;
} /* u_core_model_init2 */

/********************************************************************
* FUNCTION u_core_model_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
void u_core_model_cleanup (void)
{
    /* put your cleanup code here */
    
} /* u_core_model_cleanup */

/* END u_core_model.c */
